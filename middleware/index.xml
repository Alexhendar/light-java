<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Middleware-rsses on Light Java - The fastest Java API Framework</title>
    <link>https://networknt.github.io/light-java/middleware/index.xml</link>
    <description>Recent content in Middleware-rsses on Light Java - The fastest Java API Framework</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Released under the MIT license</copyright>
    <lastBuildDate>Sun, 06 Nov 2016 10:24:22 -0500</lastBuildDate>
    <atom:link href="https://networknt.github.io/light-java/middleware/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Traceability</title>
      <link>https://networknt.github.io/light-java/middleware/traceability/</link>
      <pubDate>Sun, 06 Nov 2016 10:24:22 -0500</pubDate>
      
      <guid>https://networknt.github.io/light-java/middleware/traceability/</guid>
      <description>

&lt;p&gt;#&lt;/p&gt;

&lt;p&gt;For microservices architecture, a request sent from client may pass through several services to the
backend respository/Book of Record and then response is returned in the reverse path. If there is an
error in the call tree, we need to identify where is the problem during runtime. Also, for some mission
critical applications, the entire call tree must be in the audit log to meet regulatory compliance
requirement. For example, Banking applications.&lt;/p&gt;

&lt;p&gt;The framework has two tracing IDs built in and X-Traceability-Id is one of them that handled by this
Middleware component. Another one is X-Correlation-Id which is documented in [Traceability]().&lt;/p&gt;

&lt;p&gt;X-Traceability-Id is generated by the original client and might not be unique across the API domain. It
is unique for that particular client though. It is usually a sequence number generated from database
or a UUID. The usage of this id is to debug broken transactions as every service will have this id
logged once if the service is called and will return this id in response header to the caller.&lt;/p&gt;

&lt;p&gt;Every API/Service is responsible to pass the X-Traceability-Id (from request header) to the next service
(set the request header by Client when calling another service).&lt;/p&gt;

&lt;p&gt;Not all client will supply traceability_id so this is an optional field in the request header. If it
doesn&amp;rsquo;t exist, do nothing. If it does exist, the framework is responsible to pass it to the next API
in the chain or pass to the Book of Record.&lt;/p&gt;

&lt;p&gt;It is recommended that X-Traceability-Id should be persisted in Backend Repository/Book of Record.
However, this might not be possible for some legacy application, i.e.
mainframe applications.&lt;/p&gt;

&lt;p&gt;It should only be logged once in the audit log once your API processing is done and successful.&lt;/p&gt;

&lt;h1 id=&#34;configuration&#34;&gt;Configuration&lt;/h1&gt;

&lt;p&gt;The configuration for this handler is very simple, just control if this handler is enabled or not.
It will only be pluged into the request/response chain if enabled is true in the traceability.json&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;description&amp;quot;: &amp;quot;Traceability Handler&amp;quot;,
  &amp;quot;enabled&amp;quot;: true
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;calling-sequence&#34;&gt;Calling sequence&lt;/h1&gt;

&lt;p&gt;This handler will be loaded after metric handler.&lt;/p&gt;

&lt;h1 id=&#34;dependencies&#34;&gt;Dependencies&lt;/h1&gt;

&lt;p&gt;This handler set the response header from request header; however, to make it work across services, it
depends the following middleware or component to work.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SimpleAuditHandler to log the traceabilityId to the audit log file.&lt;/li&gt;
&lt;li&gt;Client to pass the X-Traceability-Id to the next service through HttpRequest Header.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>sanitizer</title>
      <link>https://networknt.github.io/light-java/middleware/sanitizer/</link>
      <pubDate>Sun, 23 Oct 2016 10:35:04 -0400</pubDate>
      
      <guid>https://networknt.github.io/light-java/middleware/sanitizer/</guid>
      <description>

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;This is a middleware that addresses cross site scripting concerns. It encodes the header
and body according to the configuration. As body encoding depends on
&lt;a href=&#34;https://networknt.github.io/light-java/middleware/body/&#34;&gt;Body&lt;/a&gt; middleware, it has to be
plugged into the request/response chain after Body.&lt;/p&gt;

&lt;h1 id=&#34;configuration&#34;&gt;Configuration&lt;/h1&gt;

&lt;p&gt;Here is the default configuration sanitizer.json&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;description&amp;quot;: &amp;quot;Sanitize request for cross site scripting during runtime&amp;quot;,
  &amp;quot;enabled&amp;quot;: true,
  &amp;quot;sanitizeBody&amp;quot;: true,
  &amp;quot;sanitizeHeader&amp;quot;: true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If enabled is false, this middleware won&amp;rsquo;t be loaded during server startup.
sanitizeBody and sanitizeHeader control if body and header need to be sanitized or both.&lt;/p&gt;

&lt;h1 id=&#34;query-parameters&#34;&gt;Query Parameters&lt;/h1&gt;

&lt;p&gt;In other platforms especially JEE containers, query parameters need to be sanitized as well.
However, I have found that Undertow does sanitize special characters in query parameters. This
is why this handler doesn&amp;rsquo;t do anything about query parameters.&lt;/p&gt;

&lt;h1 id=&#34;encode-library&#34;&gt;Encode Library&lt;/h1&gt;

&lt;p&gt;The library used for cross site scripting sanitization is from &lt;a href=&#34;https://www.owasp.org/index.php/Cross-site_Scripting_(XSS&#34;&gt;https://www.owasp.org/index.php/Cross-site_Scripting_(XSS&lt;/a&gt;)
and the library can be found at &lt;a href=&#34;https://github.com/OWASP/owasp-java-encoder&#34;&gt;https://github.com/OWASP/owasp-java-encoder&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;encode-level&#34;&gt;Encode Level&lt;/h1&gt;

&lt;p&gt;The encode level we are using for both header and body is &amp;ldquo;forJavaScriptSource&amp;rdquo;. This gives us
certain level of confident and it won&amp;rsquo;t mess up header and body in most the case.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Metrics</title>
      <link>https://networknt.github.io/light-java/middleware/metrics/</link>
      <pubDate>Sat, 15 Oct 2016 20:42:32 -0400</pubDate>
      
      <guid>https://networknt.github.io/light-java/middleware/metrics/</guid>
      <description>

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;Metrics handler collects the API runtime information and report to Influxdb periodically
(5 minutes to 15 minutes based on the volume of the API). A Grafana instance is hooked to Influxdb
to output the metrics on dashboard from two different perspectives:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Client oriented - client centric info to show how many APIs to call and each API runtime info.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;API oriented - API centric info to show how many clients is calling this API.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;configuration&#34;&gt;Configuration&lt;/h2&gt;

&lt;p&gt;Here is an example of configuration.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;description&amp;quot;: &amp;quot;Metrics handler configuration&amp;quot;,
  &amp;quot;enabled&amp;quot;: true,
  &amp;quot;influxdbHost&amp;quot;: &amp;quot;localhost&amp;quot;,
  &amp;quot;influxdbPort&amp;quot;: 8086,
  &amp;quot;influxdbName&amp;quot;: &amp;quot;metrics&amp;quot;,
  &amp;quot;influxdbUser&amp;quot;: &amp;quot;admin&amp;quot;,
  &amp;quot;influxdbPass&amp;quot;: &amp;quot;admin&amp;quot;,
  &amp;quot;reportInMinutes&amp;quot;: 5
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;influxdb-and-grafana&#34;&gt;InfluxDB and Grafana&lt;/h2&gt;

&lt;p&gt;Here is the docker-compose.yml&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;influxdb:
  image: influxdb:latest
  container_name: influxdb
  ports:
    - &amp;quot;8083:8083&amp;quot;
    - &amp;quot;8086:8086&amp;quot;

grafana:
  image: grafana/grafana:latest
  container_name: grafana
  ports:
    - &amp;quot;3000:3000&amp;quot;
  links:
    - influxdb
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;metrics-collected&#34;&gt;Metrics Collected&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://networknt.github.io/light-java/images/measurements.png&#34; alt=&#34;measurements&#34; /&gt;&lt;/p&gt;

&lt;p&gt;As you can see, there two perspectives in collecting metrics info. The measurements started with clientId are client
centric info and the measurements started with API name are API centric info.&lt;/p&gt;

&lt;p&gt;Currently, we are collecting 5 metrics each.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://networknt.github.io/light-java/images/client_metrics.png&#34; alt=&#34;client metrics&#34; /&gt;&lt;/p&gt;

&lt;p&gt;This is request count for client f7d42348-c647-4efb-a52d-4c5787421e72&lt;/p&gt;

&lt;p&gt;The first column is timestamp and value column is the value for this time series. Other columns are tags and they
are endpoint, hostname/container id, ipAddress and version.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://networknt.github.io/light-java/images/api_metrics.png&#34; alt=&#34;api metrics&#34; /&gt;&lt;/p&gt;

&lt;p&gt;This is request count for API swagger_petstore.&lt;/p&gt;

&lt;p&gt;The first column is timestamp and value column is the value for this time series. Other columns are tags and they
are endpoint, hostname/container id, ipAddress and version.&lt;/p&gt;

&lt;h2 id=&#34;customization&#34;&gt;Customization&lt;/h2&gt;

&lt;p&gt;The default implementation is based on InfluxDB and Grafana which are the most popular combination
for docker containers. However, the database and dashboard can be replaced easily with another
reporter implementation. To replace it, change the MetricsHandler to use another reporter instead of
InfluxDB.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Validator</title>
      <link>https://networknt.github.io/light-java/middleware/validator/</link>
      <pubDate>Wed, 12 Oct 2016 19:13:19 -0400</pubDate>
      
      <guid>https://networknt.github.io/light-java/middleware/validator/</guid>
      <description>

&lt;p&gt;The framework encourages design driven implementation so swagger specification
should be done before the implementation starts. With the swagger-codegen
undertow generator, the server stub can be generated and start running within
minutes. However, we cannot rely on generator for validation as specification
will be changed along  the life cycle of the API. This is why we have provided
a validator that works on top of the specification at runtime. In this way,
the generator should only be used once and the validator will take the latest
spec. and validate according the spec. at runtime.&lt;/p&gt;

&lt;h1 id=&#34;fail-fast&#34;&gt;Fail fast&lt;/h1&gt;

&lt;p&gt;As you may noticed that our Status object only supports one code and message.
This is the indication the framework validation is designed as fail fast.
Whenever there is an error, the server will stop processing the request and
return the error to the consumer immediately. There are two reasons on this
design:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Security - you don&amp;rsquo;t want to return so many errors if someone is trying
to hack your server.&lt;/li&gt;
&lt;li&gt;Performance - you don&amp;rsquo;t want to spend resource to handle invalid request
to the next step.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;validatorhandler&#34;&gt;ValidatorHandler&lt;/h1&gt;

&lt;p&gt;This is the entry point of the validator and it is injected during server
start up if validator.json enableValidator is true. By default, only
RequestValidator will be called. However, ResponseValidator can be enabled
by setting enableResponseValidator to true in validator.json.&lt;/p&gt;

&lt;h1 id=&#34;requestvalidator&#34;&gt;RequestValidator&lt;/h1&gt;

&lt;p&gt;It will validate the following:
* uri
* method
* header
* query parameters
* path parameters
* body if available&lt;/p&gt;

&lt;p&gt;When necessary, schema validator will be called to do json schema validation.&lt;/p&gt;

&lt;h1 id=&#34;responsevalidator&#34;&gt;ResponseValidator&lt;/h1&gt;

&lt;p&gt;It will validate the following:
* header
* response code
* body if available&lt;/p&gt;

&lt;p&gt;when necessary, json schema validator will be called.&lt;/p&gt;

&lt;h1 id=&#34;schemavalidator&#34;&gt;SchemaValidator&lt;/h1&gt;

&lt;p&gt;If schema is defined in swagger.json, then the &lt;a href=&#34;https://github.com/networknt/json-schema-validator&#34;&gt;json-schema-validator&lt;/a&gt; will be called to validate the input against a json schema defined in draft v4.&lt;/p&gt;

&lt;h1 id=&#34;test&#34;&gt;Test&lt;/h1&gt;

&lt;p&gt;In order to test validator, the test suite starts an undertow server and serves
petstore api for testing. It is a demo on how to unit test your API during
development.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>swagger</title>
      <link>https://networknt.github.io/light-java/middleware/swagger/</link>
      <pubDate>Wed, 12 Oct 2016 19:10:34 -0400</pubDate>
      
      <guid>https://networknt.github.io/light-java/middleware/swagger/</guid>
      <description>

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;The framework is designed based on swagger specification so it is our best interest
to utilize the swagger.json to its full potential. Currently there are two
components are using the swagger spec during runtime.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Security - verify scope in the JWT token against scope defined in swagger spec
if scope verificatio is true.&lt;/li&gt;
&lt;li&gt;Validator - validate request and response based on the definition in swagger
spec for the uri and method.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;As you have noticed, both components need to have swagger operation available
based on the current request uri and method combination.&lt;/p&gt;

&lt;h1 id=&#34;cache&#34;&gt;Cache&lt;/h1&gt;

&lt;p&gt;A specification file swagger.json should be in the config folder of your API
implementation and it will be loaded to memory with SwaggerHelper during server
start up. It will be cached in memory until the server is restarted.&lt;/p&gt;

&lt;h1 id=&#34;normalized-path&#34;&gt;Normalized Path&lt;/h1&gt;

&lt;p&gt;In order to match the incoming request path to the paths defined in the swagger
specification, all paths are normalized before matching action. SwaggerHelper
provides an API to match the request path to the paths in swagger specification.&lt;/p&gt;

&lt;h1 id=&#34;swaggerhandler&#34;&gt;SwaggerHandler&lt;/h1&gt;

&lt;p&gt;This is an HttpHandler to parse the swagger spec based on the request uri and
method and attach an SwaggerOperation object to the exchange. The security and
validator modules are using it to do their job without parsing the swagger second
time.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>security</title>
      <link>https://networknt.github.io/light-java/middleware/security/</link>
      <pubDate>Wed, 12 Oct 2016 19:07:43 -0400</pubDate>
      
      <guid>https://networknt.github.io/light-java/middleware/security/</guid>
      <description>

&lt;p&gt;The current framework supports OAuth2 with JWT token but can be extended to
other authentication and authorization approaches.&lt;/p&gt;

&lt;h1 id=&#34;jwtverifyhandler&#34;&gt;JwtVerifyHandler&lt;/h1&gt;

&lt;p&gt;This is the handler that is injected during server start up if security.json
enableVerifyJwt is true. It does further scope verification if enableVerifyScope
is true against swagger specification.&lt;/p&gt;

&lt;h1 id=&#34;distributed-jwt-verification&#34;&gt;Distributed JWT verification&lt;/h1&gt;

&lt;p&gt;Unlike simple web token, the resource server has to contact Authorization server
to validate the bearer token. JWT can be verified by resource server as long as
the token signing certificate is available at resource server. Due to security
concerns, there should be two pair of private key and public key certificate
available at any time in case the primary key is compromised.&lt;/p&gt;

&lt;h1 id=&#34;light-oauth2-server&#34;&gt;light-oauth2 server&lt;/h1&gt;

&lt;p&gt;By default, the framework contains two pairs of public key certificates issued
by our own oauth2 server which can be installed from docker. For more info,
please refer to &lt;a href=&#34;https://github.com/networknt/light-oauth2&#34;&gt;https://github.com/networknt/light-oauth2&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;kid&#34;&gt;Kid&lt;/h1&gt;

&lt;p&gt;Since there are two certificates available, the kid in the header of the JWT
token will decide which certificate will be used to verify the JWT signature.&lt;/p&gt;

&lt;h1 id=&#34;jwtmockhandler&#34;&gt;JwtMockHandler&lt;/h1&gt;

&lt;p&gt;This is a testing OAuth2 endpoints provider and it can be injected into the handler
chain for unit testing so that it won&amp;rsquo;t depend on an instance of
undertow-oauth2.&lt;/p&gt;

&lt;h1 id=&#34;long-lived-token&#34;&gt;Long lived token&lt;/h1&gt;

&lt;p&gt;To make integration test easier, a long lived token is provided by the oauth2
server and it can be found at &lt;a href=&#34;https://github.com/networknt/undertow-oauth2&#34;&gt;https://github.com/networknt/undertow-oauth2&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>exception</title>
      <link>https://networknt.github.io/light-java/middleware/exception/</link>
      <pubDate>Wed, 12 Oct 2016 19:03:24 -0400</pubDate>
      
      <guid>https://networknt.github.io/light-java/middleware/exception/</guid>
      <description>

&lt;p&gt;If any handler throws an exception within the handler chain, that exception
will bubble up to the undertow server and eventually a 500 response will be
sent to the consumer. In order to change the behaviour, an exception handler
is provided to handle ApiException and other uncaught exceptions.&lt;/p&gt;

&lt;h1 id=&#34;runtime-exception&#34;&gt;Runtime Exception&lt;/h1&gt;

&lt;p&gt;Any runtime exception will be captured and return a standard 500 error with
error code ERR10010.&lt;/p&gt;

&lt;h1 id=&#34;uncaught-exception&#34;&gt;Uncaught Exception&lt;/h1&gt;

&lt;p&gt;Any checked exception that is not handled by handlers in the handler chain
is captured and return a 400 error with error code ERR10011&lt;/p&gt;

&lt;h1 id=&#34;apiexception&#34;&gt;ApiException&lt;/h1&gt;

&lt;p&gt;ApiException has a status object and it will return to consume the data defined
in the status object.&lt;/p&gt;

&lt;h1 id=&#34;logging&#34;&gt;Logging&lt;/h1&gt;

&lt;p&gt;Exception handler will log the exception with stacktrace.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Body</title>
      <link>https://networknt.github.io/light-java/middleware/body/</link>
      <pubDate>Wed, 12 Oct 2016 18:57:17 -0400</pubDate>
      
      <guid>https://networknt.github.io/light-java/middleware/body/</guid>
      <description>

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;Body is an HttpHandler to parse the body according to the content type int the
request header and attach the parsed result into the exchange so that subsequent
handlers will use it directly.&lt;/p&gt;

&lt;p&gt;The current implementation only support JSON and need content type header to be
started with &amp;ldquo;application/json&amp;rdquo;. If the content type is correct, it will parse it
to List or Map and put it into REQUEST_BODY exchange attachment.&lt;/p&gt;

&lt;p&gt;If content type is missing or if it is not started as &amp;ldquo;application/json&amp;rdquo;, the body
won&amp;rsquo;t be parsed.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://networknt.github.io/light-java/middleware/sanitizer/&#34;&gt;Sanitizer&lt;/a&gt;
and &lt;a href=&#34;https://networknt.github.io/light-java/middleware/validator/&#34;&gt;Validator&lt;/a&gt;
depend on this middleware.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Audit</title>
      <link>https://networknt.github.io/light-java/middleware/audit/</link>
      <pubDate>Wed, 12 Oct 2016 18:48:58 -0400</pubDate>
      
      <guid>https://networknt.github.io/light-java/middleware/audit/</guid>
      <description>

&lt;p&gt;There are two builtin audit handlers that write logs into audit.log that setup in the
logback appender.&lt;/p&gt;

&lt;h1 id=&#34;simpleaudithandler&#34;&gt;SimpleAuditHandler&lt;/h1&gt;

&lt;p&gt;Only logs several fields from request header and the fields are configurable.
Optional, it can log response status and response time.&lt;/p&gt;

&lt;h1 id=&#34;fullaudithandler&#34;&gt;FullAuditHandler&lt;/h1&gt;

&lt;p&gt;Dump every thing from request and response. This is mainly a development tool
and may be used on production for some of the APIs without performance concerns.&lt;/p&gt;

&lt;h1 id=&#34;customized-handler&#34;&gt;Customized Handler&lt;/h1&gt;

&lt;p&gt;For some users that need special audit logic or other channel to redirect the audit
to, they can create their own audit handler and replace the default audit handler in
/src/main/resources/META-INF/services/com.networknt.handler.MiddlewareHandler&lt;/p&gt;

&lt;p&gt;Before updating this file, please read this [document]()&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Middleware Handlers</title>
      <link>https://networknt.github.io/light-java/middleware/</link>
      <pubDate>Fri, 07 Oct 2016 22:02:13 -0400</pubDate>
      
      <guid>https://networknt.github.io/light-java/middleware/</guid>
      <description>

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;light-java is a Java API framework based on undertow http core that supports
swagger code generation and runtime request validation.&lt;/p&gt;

&lt;p&gt;It contains the following components:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://networknt.github.io/light-java/middleware/security/&#34;&gt;security&lt;/a&gt; - oauth2 jwt token verification and mock token generation. Also,
there is an testing OAuth2 server released &lt;a href=&#34;https://github.com/networknt/light-oauth2&#34;&gt;here&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://networknt.github.io/light-java/middleware/validator/&#34;&gt;validator&lt;/a&gt; - validate request based on the swagger.json for uri parameters,
query parameters and body which is based on &lt;a href=&#34;https://github.com/networknt/json-schema-validator&#34;&gt;json-schema-validator&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://networknt.github.io/light-java/middleware/audit/&#34;&gt;audit&lt;/a&gt; - dump most important info about request and response into audit.log in
JSON format. Also, there is a full audit handler to dump everything regarding to
request and response.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://networknt.github.io/light-java/middleware/body/&#34;&gt;body&lt;/a&gt; A body parser middleware that is
responsible for parsing the content of the request based on Content-Type in the request header.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://networknt.github.io/light-java/middleware/exception/&#34;&gt;exception&lt;/a&gt; A generic exception
handler that handles runtime exception, ApiException and other checked exception if they are not handled
properly in the handler chain.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://networknt.github.io/light-java/middleware/metrics/&#34;&gt;metrics&lt;/a&gt; A module that collect
API runtime info based on clientId and API name. The metrics info is sent to InfluxDB and accessible
from Grafana Dashboard.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://networknt.github.io/light-java/middleware/swagger/&#34;&gt;swagger&lt;/a&gt; This is a middleware
that load swagger at runtime and parse it based on the request uri and method and attached the
swagger data related to the current endpoint into the exchange for subsequent handlers to use.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://networknt.github.io/light-java/middleware/sanitizer/&#34;&gt;sanitizer&lt;/a&gt; This is a middleware
that address cross site scripting concerns. It encodes header and body based on configuration.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>